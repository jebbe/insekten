Movements | Movements degrading | Stock | Stock degrading            
 4                                  10                      Total       
 50          5                      1       100            Queen       
 0.5         10                     1       100            Ant         
 1           5                      1       100            Spider      
 1           5                      1       100            Cricket     
 1           5                      1       100            Beetle      
 0.8         5                      1       100            Ladybug     
 0.5         5                      1       100            Mosquito    
 3           5                      1       100            Pillbug     
80 Score_per_free_bee_neighbor
100 Score_for_unplaced_queen
2 placement_weight
1e4 Victory
-5 draw

This table determines the evaluation function, the core of the AI. It evaluates
the current board position based on four terms:
1) The number of free tiles adjacent to the queen bee
2) The number of possible movements around the board, where each combination of
   origin/destiniation is considered one movement.
3) The number of possible placements of new pieces, where each combination of
   piece/destination tile is considered one placement.
4) The number of pieces that have not been placed.
5) Winning/losing the game or playing draw.

Terms 2 and 4 are weighted with a global factor (first row of the table), and, in 
addition, the contributions are weighted with a factor for each piece, so that
you can make e.g. the ants free movements less valuable.

The terms are calculated as folows:
1) If the queen has been placed: 
      Score_per_free_bee_neighbor*[free tiles around the queen bee]
   If the queen has not been placed:
      Score_for_unplaced_queen
   This should account for the fact that not placing the queen basically means that
   we have 6 free spaces around the queen bee.

2) This term is calculated as 
      Movements * sum_over_pieces( (#moves * (Movements_piece + mvmnts_dgr) / (N + mvmnts_dgr) ) )
   where N is the move counter. mvmnts_dgr gives you the opportunity to make 
   flexibility less valuable later in the game.

3) This term just adds up all the number of tiles we can place new pieces on 
   nad weighs them according to the placement_weight.

4) This term is calculated as 
      Stock * sum_over_pieces( (#pieces * (Stock_piece + stock_dgr) / (#pieces + stock_dgr) ) )
   Here, the number of pieces of this kind can be made less significant by
   increasing stock_dgr, such that e.g. two ants in stock aren't twice as valuable
   as one ant in stock.
      
5) Victory is the score we get for winning the game, draw can e.g. be set negative to
   make the AI try and avoid draw.
   
The higher stock_degrading, the less valuable additional unplaced pieces.
The higher movements_degrading, the faster the movability of a piece becomes less 
valuable during the game.
